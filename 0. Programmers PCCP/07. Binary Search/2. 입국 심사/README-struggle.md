# 입국 심사

## 문제 개요

-   문제 유형: 이진 탐색
-   문제 난도: 프로그래머스 Lv3, 46% (2025/01)
-   문제 링크: https://school.programmers.co.kr/learn/courses/30/lessons/43238

## 문제 내용 설명

-   전체 입국 심사를 받는 최소 시간 = ?
-   n명의 심사 대상자 (1 <= n <= 10억)
-   m개의 심사대 (1<= m <= 10만)
-   각 심사관의 심사 시간(분) t (1 <= t <= 10억)

### 문제 입출력

-   입력 값: 심사 대상자 수 n, times(심사대 별 심사 시간 정수의 배열)
-   출력 값: 전체 사람이 심사를 받는 최솟값

(예시)

```
- n=6, times=[7, 10]
- t=00, 1, 2 시작
- t=07, 3 시작
- t=10, 4 시작
- t=14, 5 시작
- t=20, (6은 대기를 한다.)
- t=21, 6 시작
- t=28, 6 끝
```

## 문제 해설

-   문제 풀이 방법 도출
-   수도 코드
-   사용 단위 알고리즘 종류
-   사용 단위 알고리즘 구현
-   문제 해결 코드

### 1. 문제 풀이 방법 도출

-   단순 반복으로는 해결할 만한 시간복잡도가 아니다.
-   실마리는 유일한 순회 대상인 심사대 10만개이다.
-   심사 대상자 \* 심사 시간 = 10억 \* 10억
    -   number로는 처리가 어려울 수 있는데, 별도의 % 사용 지시가 없어 정수 범위를 넘진 않는다고 가정하고 진행

#### 1-1. [접근 시도 1] 이진 탐색?

-   이진 탐색을 쓴다면 어떻게 쓰는가?
    -   궁금증
        -   이미 심사 중인 심사대 처리는 어떻게 할까?
        -   전체 소요 시간은 어떻게 더할까?
    -   심사대의 소요 시간 오름차순으로 정렬한 후에도 어떻게 처리할 수 있을까?
        -   첫 케이스만 막 해봅시다
            -   소요 시간 오름차순이니까 선형 탐색해서 빠르게 찾기?
            -   이진 탐색으로 해봤자, 심사 중인지 아닌지는 알 수가 없다.
                -   심사 여부 배열을 별도로 관리하는 것? 조금 애매하다. 항상 최솟값으로 가는 건 좀, 이상하지 않나?

#### 1-2. [접근 시도 2] PQ?

-   "심사 여부" 개념을 사용한다면, PQ(min heap)가 가장 적합한 형태인 듯하다.

    -   PQ의 시간 복잡도 = 넣을 때, 뺄 때 log N, log2(10만) = 1024 \* 1024 / 10 = 20-3= 17 정도?
    -   17 \* 10억 = 170억...?
        -   이 접근은 아닌 듯
    -   10억회는 최소한 반복해야 한다고 보면

        -   PQ 생성, 초기화
        -   PQ에서 차례대로 출력하면서 그만큼 t를 더하고,
        -   동시에 이미 나온 심사대는 심사가 끝난 시점에 다시 PQ에 넣는다.
        -   이 때, 심사 중인 심사대도 대기 시간을 더한 채로 선택 대상에 포함이 되어야 한다.
        -   PQ로 하기에 복잡하다고 느껴지는데,

            -   {원래시간,대기시간} 더해서 넣는다? 이거는 PQ로 할 수는 없을 거 같은데?
            -   매 선택 루프마다 PQ 아이템에서 {대기시간}을 전부 갱신해줄 순 없음
            -   PQ 내부에서 임의의 시점에 값이 바뀌면, 정렬이 불가능해짐.

#### 1-2. [접근 시도 3] PQ가 아닌 방법? + 10억 미만의 방법?

-   역시 10억, 170억 이건 좀 아닌 듯 해서, 더 작은 방법을 고민해볼 필요가 있다고 생각이 든다.

    -   문득 든 생각: n이 상관 없는 거 아닐까?
        -   10만개 배열만 지지고 볶아야 될 것 같은데
        -   즉, n이 시간 복잡도와 관계 없어야 함

-   근데 애초에 10억명을 순회하지 않을 수 없기 때문에, N log M 정도면 최소 시간 복잡도라고 보고, 일단 이진 탐색으로 돌아간다.

#### 1-2. [접근 시도 3] 다시 이진 탐색으로

-   PQ 때의 접근은 각 심사마다 pop, push를 반복하는 것이었는데, 이렇게 되면 매번 정렬해야 하는 문제가 있고 이는 매우 느리다.
-   이진 탐색을 한다면 pop, push가 없는 어떠한 방법이 필요하다.
-   그런 게 가능할까?

#### 1-3. [접근 시도 4] (다음 날) 처음부터 다시 진행 - 떠오르는 방법들 검증해보기

-   단순하게 떠오르는 방법들을 검증해보자.

-   SOLUTION 1: 모든 심사대를 가동한다.
    -   반례: 심사 시간 = (1, 2, 10억)이면, 10억을 제외한 나머지 심사대만을 반복하는 게 빠르다.
-   SOLUTION 2: 최소 시간의 심사대만 가동한다.
    -   반례: 심사 시간 = [9, 10]인 경우, 9\*2(=18)보다 10이 더 빠르다.
-   SOLUTION 3: 각 입국 심사 대상자마다의 최소 시간을 판단하면, 전체의 최소가 달성되는가?

    -   반례: 심사 시간 = [1,3], 심사대상자=10일 때, 매번 1을 기다리는 것이 개인에게는 더 빨라도, 전체로는 더 느리다.

-   기준을 무엇을 두고 개별 심사대를 선택해야 하는가?

    -   기준을 둔다는 것은 개별 심사 대상자마다 스케줄링을 하는 것을 의미한다.
        -   Solution 3에 의해 틀렸음이 증명되었다.

-   전체를 가장 빠르게 하는 특정한 방법이 있을까?

    -   모든 심사대를 가동하되, 가장 빠른 심사대로 전원을 심사하는 것보다 느린 심사대는 스케줄링에서 아예 제외한다.

        -   (ex) 심사대=[1, 2, 3, 4, 5억, 10억]이 있고, 심사 대상이 10만명이면, 5억, 10억은 제외한다.
            -   반례: 심사대=[1, 2, 3, 4, 10], 심사 대상=30명,
                -   가동 = [1,2,3,4,10]
                -   1\*10, 2\*5, 3\*3, 4\*2, 10\*1 = 10 한 바퀴 당 21명
                -   9명이 남았을 때, [1,2,3,4]만으로 처리하면 = 1\*5, 2\*2, 3\*1, 4\*1 = 9명 = 5분 소요
                    -   Q. 이거 최소 맞음? 최소 맞음.
                -   만약 이 때 [1,2,3,4,10]으로 처리했다면? 10초가 걸림.

    -   마지막 순서가 아닌 경우는, 모든 심사대를 가동해서 처리한다.

        -   얼마나 걸리는지 계산하는 방법?

    -   마지막 순서의 경우 최선의 선택을 진행한다.
        -   마지막 순서 바로 전의 경우는 상관이 없나?

#### 1-4. [접근 시도 5] 절대 문제가 이런 식으로 나오진 않을 것임....

-   여러 가지 Solution을 생각해보았을 때 점점 혼란스러워진다.

#### 1-5. [접근 시도 6] 이진 탐색을 정 써야 한다면

-   아마도 남은 시간에 가장 적합한 심사대를 찾으려고 할 것 같은데..?
-   근데 그냥 막 할 수는 없을텐데...?
-   남은 방법이라고 할 게 이거 밖에 없다...

```
(기본 예시 case)
- n=6, times=[7, 10]
- t=00, 1, 2 시작 <-- 사용 가능 = [7, 10]
- t=07, 3 시작 <-- 사용 가능 = [7, 10(+3)]
- t=10, 4 시작 <-- 사용 가능 = [7(+4), 10]
- t=14, 5 시작 <-- 사용 가능 = [7, 10(+6)]
- t=20, (6은 대기를 한다.) <-- 사용 가능 = [7(+1), 10]
- t=21, 6 시작 <-- 사용 가능 = [7, 10]
- t=28, 6 끝
```

-   이렇게 보면, 대기 시간도 포함한 min heap이 맞는 거 같은데... 흠?

#### 1-6. [접근 시도 7] 대기 시간을 포함한 min heap

-   heap에 들어가 있는 상태이면 실시간으로 값을 바꿀 수는 없을 것이다.
    -   근데 필요는 한데...
        -   흠....
            -   어떻게 해야 할까?
            -   흠...............
                -   다음에 생각해보자!
