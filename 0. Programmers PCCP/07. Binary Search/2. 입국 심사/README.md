# 입국 심사

## 문제 개요

-   문제 유형: 이진 탐색
-   문제 난도: 프로그래머스 Lv3, 46% (2025/01)
-   문제 링크: https://school.programmers.co.kr/learn/courses/30/lessons/43238

## 문제 내용 설명

-   전체 입국 심사를 받는 최소 시간 = ?
-   n명의 심사 대상자 (1 <= n <= 10억)
-   m개의 심사대 (1<= m <= 10만)
-   각 심사관의 심사 시간(분) t (1 <= t <= 10억)

### 문제 입출력

-   입력 값: 심사 대상자 수 n, times(심사대 별 심사 시간 정수의 배열)
-   출력 값: 전체 사람이 심사를 받는 최솟값

(예시)

```
- n=6, times=[7, 10]
- t=00, 1, 2 시작
- t=07, 3 시작
- t=10, 4 시작
- t=14, 5 시작
- t=20, (6은 대기를 한다.)
- t=21, 6 시작
- t=28, 6 끝
```

## 문제 해설

-   문제 풀이 방법 도출
-   수도 코드
-   사용 단위 알고리즘 종류
-   사용 단위 알고리즘 구현
-   문제 해결 코드

### 1. 문제 풀이 방법 도출

-   단순 반복으로는 해결할 만한 시간복잡도가 아니다.
-   실마리는 유일한 순회 대상인 심사대 10만개이다.
-   심사 대상자 \* 심사 시간 = 10억 \* 10억
    -   number로는 처리가 어려울 수 있는데, 별도의 % 사용 지시가 없어 정수 범위를 넘진 않는다고 가정하고 진행

#### 1-1. [접근 시도 1] 이진 탐색?

-   이진 탐색을 쓴다면 어떻게 쓰는가?
    -   궁금증
        -   이미 심사 중인 심사대 처리는 어떻게 할까?
        -   전체 소요 시간은 어떻게 더할까?
    -   심사대의 소요 시간 오름차순으로 정렬한 후에도 어떻게 처리할 수 있을까?
        -   첫 케이스만 막 해봅시다
            -   소요 시간 오름차순이니까 선형 탐색해서 빠르게 찾기?
            -   이진 탐색으로 해봤자, 심사 중인지 아닌지는 알 수가 없다.
                -   심사 여부 배열을 별도로 관리하는 것? 조금 애매하다. 항상 최솟값으로 가는 건 좀, 이상하지 않나?

#### 1-2. [접근 시도 2] PQ?

-   "심사 여부" 개념을 사용한다면, PQ(min heap)가 가장 적합한 형태인 듯하다.

    -   PQ의 시간 복잡도 = 넣을 때, 뺄 때 log N, log2(10만) = 1024 \* 1024 / 10 = 20-3= 17 정도?
    -   17 \* 10억 = 170억...?
        -   이 접근은 아닌 듯
    -   10억회는 최소한 반복해야 한다고 보면

        -   PQ 생성, 초기화
        -   PQ에서 차례대로 출력하면서 그만큼 t를 더하고,
        -   동시에 이미 나온 심사대는 심사가 끝난 시점에 다시 PQ에 넣는다.
        -   이 때, 심사 중인 심사대도 대기 시간을 더한 채로 선택 대상에 포함이 되어야 한다.
        -   PQ로 하기에 복잡하다고 느껴지는데,

            -   {원래시간,대기시간} 더해서 넣는다? 이거는 PQ로 할 수는 없을 거 같은데?
            -   매 선택 루프마다 PQ 아이템에서 {대기시간}을 전부 갱신해줄 순 없음
            -   PQ 내부에서 임의의 시점에 값이 바뀌면, 정렬이 불가능해짐.

#### 1-2. [접근 시도 3] PQ가 아닌 방법? + 10억 미만의 방법?

-   역시 10억, 170억 이건 좀 아닌 듯 해서, 더 작은 방법을 고민해볼 필요가 있다고 생각이 든다.

    -   문득 든 생각: n이 상관 없는 거 아닐까?
        -   10만개 배열만 지지고 볶아야 될 것 같은데
        -   즉, n이 시간 복잡도와 관계 없어야 함

-   근데 애초에 10억명을 순회하지 않을 수 없기 때문에, N log M 정도면 최소 시간 복잡도라고 보고, 일단 이진 탐색으로 돌아간다.

#### 1-2. [접근 시도 3] (4가지 시도 생략)

-   (생략)

#### 1-3. [정답 확인] 시간에 대해 이진탐색

> 발상이 꽤 어렵다..

-   총 심사 시간의 (최소, 최대)를 이진 탐색한다.
-   최소 = 1, 최대 = `n * Math.max(...times)` (JS BigInt 사용 필요)
-   선택된 "총 심사 시간"에 대해 "전체 심사대가 총 n명 이상을 심사할 수 있는지"로 탐색을 이어나간다.
-   충분히 심사할 수 있어도 "총 심사 시간"을 줄여나간다. (?)
    -   이진 탐색에 대한 개념 또 잊겠음.

### 2. 수도 코드

-   (생략)

### 3. 사용 단위 알고리즘 종류

-   이진탐색 - lowerBound

### 4. 사용 단위 알고리즘 구현 / 완성 코드

```js
// 입국 심사용 lowerBound
const solution = (n, times) => {
    const people = BigInt(n);

    let low = 1n;
    let high = people * BigInt(times[times.length - 1]) + 1n; // high는 정상 범위 + 1

    const maxTourists = (totalTime) =>
        times.reduce((sum, time) => sum + totalTime / BigInt(time), 0n);

    while (low < high) {
        const mid = (low + high) / 2n;
        if (people > maxTourists(mid)) {
            low = mid + 1n;
        } else {
            high = mid;
        }
    }
    return low;
};
```

### 5. 배운 점

-   동적인(?) 값, 주어지지 않은 값에 대해서도 이진 탐색을 할 수 있다는 깨달음을 얻었다.
-   이 문제는 "시간에 대해 탐색한다"는 발상으로는 아예 접근하지 못했는데, 계속 시뮬레이션 방식으로 풀려고 했기 때문이다. 아마 계속해서 못 풀었을 것 같다.
-   이진 탐색의 구현 방법에 대해서 다시 유도해보면서, 특정 값을 찾는 탐색, lower/upper bound 탐색의 기능과 구현 방법을 익혔다.
-   오래 걸렸지만 뿌듯했다.
