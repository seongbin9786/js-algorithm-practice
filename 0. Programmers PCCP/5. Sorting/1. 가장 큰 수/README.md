# 가장 큰 수

> 답변을 보고 이해만 한 문제이기 때문에, 다시 연습이 필요하다. (2024/12/20)

## 문제 개요

-   문제 유형: 정렬
-   문제 난도: 프로그래머스 Lv2, 55% (2024/12)
-   문제 링크: https://school.programmers.co.kr/learn/courses/30/lessons/42746

## 문제 내용 설명

-   0, 자연수로 구성된 배열의 원소들을 이어붙여서 만들 수 있는 가장 큰 수를 반환
-   1 <= numbers.length <= 100,000
-   0 <= numbers[i] <= 1,000
-   문자열로 변환해 반환

### 문제 핵심 내용 요약

-   입력 값: 0, 자연수로 구성된 배열
-   출력 값: 배치를 해서 만들 수 있는 가장 큰 값을 문자열로 출력

예시

-   주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210

## 문제 해설

-   문제 해결책 설명
-   수도 코드
-   사용 단위 알고리즘 종류
-   사용 단위 알고리즘 구현
-   문제 해결 코드

### 1. 문제 해결책 설명

-   백트래킹으로 해결하기는 어렵다. 길이가 10만이어서 전체 순열을 생성하는데 10만!이 필요하다.

#### 1-1 [접근 1]

-   정렬로 해결한다면, 앞 자리수가 높은 게 중요하므로 자리수 비교로 내림차순 정렬할 수 있다.
-   서로 다른 자리수의 숫자일 수 있기 때문에 앞 자리수부터 비교한다.
-   자리수가 다른 경우는 어떻게 해야 하나? (ex) [9,91,80,87,8] = (??) 잘 모르겠다. 어떤 알고리즘을 활용하는 문제는 아니다.

예시

-   9 vs 91 = 뭐가 앞에? 9
    -   91,9 vs 9,91 = 991이 더 크다.
-   8 vs 91 = 뭐가 앞에? 91
    -   8,91 vs 91,8 = 918이 더 크다
-   무조건 더 짧은 걸 쓰면 되나? X
    -   999,91 vs 91,999 = 99991이 더 크다
-   동일 선상에서는 더 짧은 게 항상 앞에 오는가?
    -   9,91,8,89 vs 9,91,89,8 = 991898이 더 크다
    -   음~ 마지막 자리수보다 더 큰 숫자가 그 다음 자리수에 배치되면 된다.

#### 1-2 [접근 2]

> 외부 답을 확인했다.

-   직접 패턴을 찾기보다, 단순히 a와 b를 직접 붙여보고 더 큰 것을 앞에 배치하면 된다.

> 이해한 내용:

-   서로 길이가 다른 문자열을 비교하는 것은 복잡하다.
-   a,b를 순서를 바꿔 두 번 붙여보는 경우는, 비교할 때 서로 길이가 동일하다.
-   길이가 동일한 문자열은 같은 자리수의 숫자끼리 비교해 내림차순 정렬하면 된다.
-   이는 `(a+b).localeCompare(b+a) \* -1`로 가능하다.

#### 1-2. [접근 1에 대한 추가 확인]

### 2. 수도 코드

1. 비교 함수를 작성한다. (a, b)를 입력받았을 때 둘을 합쳐보고, `a.localeCompare(b)`로 비교한다. 1, -1, 0을 반환한다.
2. 입력된 배열을 (1)로 정렬한다.
3. 정렬 결과를 빈 문자로 join하고 반환한다.

### 3. 사용 단위 알고리즘 종류

-   정렬

### 4. 사용 단위 알고리즘 구현

-   언어 내장 정렬 사용

### 5. 단위 알고리즘 활용 코드

#### 5-1. 첫 시도 코드

-   문자열로 합치기 위해
-   내림차순 정렬을 위해 -1을 곱해주었다.

```js
const solution = (numbers) => {
    const compareFunction = (_a, _b) => {
        const a = _a.toString();
        const b = _b.toString();
        return (a + b).localeCompare(b + a) * -1;
    };
    return numbers.sort(compareFunction).join("");
};
```

-   TC 중 하나가 틀렸다.

> 무엇이 틀렸는지 몰라서 외부 답을 확인해보았다.

-   0이 예외라고 해서(ex: `00000`), 예외 처리를 추가했다.

```js
const solution = (numbers) => {
    const compareFunction = (_a, _b) => {
        const a = _a.toString();
        const b = _b.toString();
        return (a + b).localeCompare(b + a) * -1;
    };

    const result = numbers.sort(compareFunction).join("");
    return result[0] === "0" ? "0" : result;
};
```
