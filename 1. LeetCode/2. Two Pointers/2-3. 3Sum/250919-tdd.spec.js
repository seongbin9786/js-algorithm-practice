import { describe, it, assert } from "vitest";

/*
1. 조건을 명확히 이해해야 함. 특히, 단일 구현 사이클이 길어지는 경우 정말 명확히 이해해야 함.

[풀이 과정 정리 - 내 시도]
1. 알고리즘 시간 복잡도 접근: O(n^2)까지는 가능하고, 그것보다 줄이는 건 불가능해보였음(떠오르지 않았음)
2. 실제로 풀어보니, O(n^2)에서도 좀 더 최적화가 필요했음(TLE). 중복 방문을 제거해야만 TLE를 통과할 수 있으므로 단순 순회로 해결 불가능함.
3. 중복 순회를 없애야 함: i<j<k --> 조합 경우의수만 정확히 확보
4. 중복 결과를 없애야 함: 중복 값 때문에, 조합 경우의수만 구해도 여전히 중복이 발생함
5. i,j를 구하고, Map으로 세번째 숫자를 구하되 k>j>i를 준수하면 '중복 순회' 케이스는 없앨 수 있는데, '중복 결과'를 없앨 수 없음.

[정답 풀이 과정 정리]
1. n=3,000이어서 n^3 으로는 270억, n^2으로는 900만 -> n^3은 일단 안 되고, n^2 정도로 접근 필요
2. (해보고 나서 알게 되었지만 불필요한 순회가 없어야 하는 것 같아요)
3. n^2으로 잡으려면, 순회가 2번만 중첩되어야 함 -> 그냥은 할 수 없음.
4. 우선 숫자들의 '조합'이기 때문에 i<j<k 만 순회하면 됨.
5. (투포인터 이해도 필요) 추가적으로 투포인터를 사용하면 i<j<k 루프의 불필요한 체크를 제거할 수 있음 (중복도 자연히 제거됨)
6. 투포인터를 사용하더라도 nums[i]가 동일할 수 있으므로, '연속된 중복값'들은 생략해야 함 -> i,j,k를 선택할 때 모두 해당함 -> 단순한 루프로 해결

[회고]
1. 처음의 방식으로 해결하려고 고집해서 엄청 시간을 낭비했습니다. (2개만 선택하고 나머지 하나를 Map에서 선택)
2. 그동안 그렇게 시간을 낭비해보았는데, 능력의 향상이 있는 것 같지 않고, 오히려 아이디어 발상이 막힌채로 기약이 없는 경우 기존 접근을 잘 정리하고, 답변을 최소한만 참고해서 발상의 차이가 발생한 지점을 잘 회고하는 게 유일한 방법 아닐까 생각이 들었습니다
*/
describe("3Sum", () => {
    it.each([
        // 기본
        [[0, 0, 0], [[0, 0, 0]]],
        [[-1, 0, 1], [[-1, 0, 1]]],
        // // 정렬 순서 무관 TC
        [[1, 0, -1], [[-1, 0, 1]]],
        // // 조합이 없는 경우
        [[1, 2, 3], []],
        [[-1, -2, -3], []],
        // // 여러 조합이 가능한 경우
        [[-3, -2, 1, 2, 3], [[-3, 1, 2]]],
        // value까지도 조합인 Case
        [[0, 0, 0, 0], [[0, 0, 0]]],
        // i<j 여도 중복 가능한 경우 ([-1,0,1]이 2번 나오게 됨)
        [[-1, -1, 0, 1], [[-1, 0, 1]]],
        // 리트코드 TC
        [
            [-1, -1, 0, 1, 2],
            [
                [-1, -1, 2],
                [-1, 0, 1],
            ],
        ],
        // 나의 예외 체크
        [
            /*
            3, -3 -> [x]
            -3, 2, -> [x]
            나는 이게 투포인터가 될 수 있다는 감이 전혀 안 옴
            양쪽에서 고르는데 어떻게 ([-2,-1,3]을 고를 수 있음?)
            -> 고를 수는 있음. -2, 3을 고르면 -1을 고를 수 있음
            -> 흠.. 이 방식으로 하면 어떻게 중간 놈을 찾을 수 있지? 여러 개가 있을텐데. last index로 충분한가?
            -> (-3,3), (-3,2), (-2,3), (-2,2), (-2,1), (-1,2), (-1,1)
            -> 이런 식으로 하면
            -> 일단, 개념이 서지 않으므로 취소함
            -> 0을 경계로 두고, 0에 진입하지 않음.
            */
            [-3, -2, -1, 0, 1, 2, 3],
            [
                [-3, 0, 3],
                [-3, 1, 2],
                [-2, -1, 3],
                [-2, 0, 2],
                [-1, 0, 1],
            ],
        ],
        // 리트에서 준 반례..
        // -1 0 0 1 이면?
        // -1 0 - 1
        // -1 - 0 1
        // 하...ㅋㅋ 머리가 안 좋아..
        // 이렇게 반례 만드는 법을 배우는 거지 뭐. 되게 좋은 거 같음.
        // 0이 조합에 들어가면 답이 없네?
        /*
        1. 양 끝에서 -1, 1을 고르고, 0을 고르면, 방금 고른 게 0이라면 그 다음에 0을 생략할 수도 있겠죠? 정렬되어 있으니깐 항상 직전만 비교하면 되고요.
        2. 
        */
        [[-1, 0, 0, 1], [[-1, 0, 1]]],
    ])("%j => %j", (input, expected) => {
        const result = threeSum(input);

        assert.deepEqual(
            result.map((combo) => combo.sort()).sort(compareTriple),
            expected.map((combo) => combo.sort()).sort(compareTriple)
        );
    });
});

function compareTriple(a, b) {
    if (a[0] !== b[0]) {
        return a[0] - b[0];
    }
    if (a[1] !== b[1]) {
        return a[1] - b[1];
    }
    if (a[2] !== b[2]) {
        return a[2] - b[2];
    }
    return 0;
}

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
    nums.sort((a, b) => a - b);

    const triplets = [];

    for (let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i - 1] === nums[i]) {
            continue;
        }
        console.log(`i: ${i}, nums[i]: ${nums[i]}`);
        const target = nums[i] * -1;
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
            const sum = nums[left] + nums[right];
            if (sum === target) {
                triplets.push([nums[i], nums[left], nums[right]]);

                right--;
                while (nums[right + 1] === nums[right]) {
                    right--;
                }

                left++;
                while (nums[left - 1] === nums[left]) {
                    left++;
                }
            } else if (sum > target) {
                right--;
                while (nums[right + 1] === nums[right]) {
                    right--;
                }
            } else {
                left++;
                while (nums[left - 1] === nums[left]) {
                    left++;
                }
            }
        }
    }

    return triplets;
};
