/*
[문제 해석]
- 일직선 상에 위치하지 않은 세 점이 주어졌을 때, 세 점을 통과하는 원의 원주(둘레)를 반환

[발상 요약]
1. 일직선 상에 위치하지 않은 세 점을 받아서 반지름을 구하려고 함.
2. 반지름 구하려면 식 연립을 통해 중점(a,b)를 구한 후, 원의 방정식에 x,y,a,b를 대입해 r을 구할 수 있음
3. 연립해서 식을 세웠더니 분모식 != 0을 증명해야 함
4. (3)을 증명하려고 봤더니, 세 점 P1,P2,P3 로 만든 두 벡터의 외적이었고, 이 외적은 평행사변형의 넓이이므로 0이 될 수가 없는 거임 (일직선 상의 세 점이 아니므로)

[발상]
- 원의 방정식 연립하면 되는 거 아님?
    - (y-b)^2 + (x-a)^2 = r^2 이면 return 2파이r (파이 = 3.141592653589793 로 계산)
    - 2파이r <= 100만
    - r <= 13만 정도 (근데 소수점 가능해서 브루트포스로는 안 될 거 같은데)
    - 연립하면 끝이지
    - 근데 연립이 되게 복잡한 문제인데... 이게 손으로 하면 쉬운데 일반화를 하려니 좀 어려워짐.
- 반지름을 구하는 방법: 중점을 먼저 구해서 대입해서 구하기
    - 일단 연립해서, 중점(a,b)을 구하고, 중점을 원의 방정식에 대입해서 r을 구하면 됨 (참고로, 다른 공식 사용할 수도 있음)
    - 연립 식도 세우려면 요리조리 해봐야 하지만...
    - 연립하다보면 나눗셈을 하게 되는데 분모가 0이 아니라는 증명을 해야 함 (이 증명이 복잡함)
    - 연립하면 a=(B_2*C_1 - B_1*C_2)/2(A_1*B_2 - A_2*B_1), b=(A_2*C_1 - A_1*C_2)/2(A_2*B_1 - A_1*B_2)
    - 이 때 A_1=(x_1 - x_2), A_2=(x_1 - x_3), B_1=(y_1 - y_2), B_2=(y_1 - y_3), C_1=(x_1^2 - x_2^2 + y_1^2 - y_2^2), C_2=(x_1^2 - x_3^2 + y_1^2 - y_3^2)
- 증명하려면 벡터에 관해서 조금 알아야 함.
    - 벡터의 외적 개념은 2차원, 3차원으로 나뉨
    - 벡터의 외적의 크기는 [평행사변형의 크기]임 (참고로 외적 공식은 벡터 u, v에 대해 u_x*v_y - u_y*v_x)
    - 세 점으로 두 벡터를 만들 수 있음. (e.g. P1, P2, P3가 있을 때, P1->P2, P1->P3 벡터를 만들 수 있음)
    - 두 벡터로 평행사변형의 크기를 구했을 때, 크기가 0이면 세 점은 삼각형을 이루지 못하며, 원주에 위치할 수도 없음 (직관적으로 당연하죠??)
    - 근데 이 분모에 들어가는 식이 놀랍게도- 이 P1,P2,P3로 구성한 두 벡터의 외적(=평행사변형의 넓이)인 거임.
    - 그러니깐 문제에서처럼 "일직선 상에 위치하지 않은 세 점"이 주어진다면 분모도 0이 될 수 없음.
*/

import { describe, it, assert } from "vitest";

describe("원의 둘레 (Silver 1)", () => {
    it.each([
        [0.0, -0.5, 0.5, 0.0, 0.0, 0.5, 3.14],
        [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 4.44],
        [5.0, 5.0, 5.0, 7.0, 4.0, 6.0, 6.28],
        [0.0, 0.0, -1.0, 7.0, 7.0, 7.0, 31.42],
        [50.0, 50.0, 50.0, 70.0, 40.0, 60.0, 62.83],
        [0.0, 0.0, 10.0, 0.0, 20.0, 1.0, 632.24],
        [0.0, -500000.0, 500000.0, 0.0, 0.0, 500000.0, 3141592.65],
    ])("%j,%j => %i", (x1, y1, x2, y2, x3, y3, expected) => {
        const result = solution(x1, y1, x2, y2, x3, y3);
        assert.equal(result, expected);
    });
});

function solution(x1, y1, x2, y2, x3, y3) {
    const A1 = x1 - x2;
    const A2 = x1 - x3;
    const B1 = y1 - y2;
    const B2 = y1 - y3;
    const C1 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2;
    const C2 = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3;

    const a = (B2 * C1 - B1 * C2) / (2 * (A1 * B2 - A2 * B1));
    const b = (A2 * C1 - A1 * C2) / (2 * (A2 * B1 - A1 * B2));

    const r = Math.sqrt((x1 - a) * (x1 - a) + (y1 - b) * (y1 - b));

    return Number(2 * r * Math.PI).toFixed(2);
}

function bojRun() {
    const fs = require("fs");
    const input = fs.readFileSync(0, "utf-8").trim().split("\n");

    input.forEach((row) => {
        const [x1, y1, x2, y2, x3, y3] = row.split(" ").map(Number);
        const result = solution(x1, y1, x2, y2, x3, y3);
        console.log(result);
    });
}

bojRun();
